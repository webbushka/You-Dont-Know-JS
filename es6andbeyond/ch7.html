<!doctype html>
 <html>
   <head>
     <link rel="stylesheet" href="../style.css">
     <title>ES6 & Beyond</title>
     <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/github.min.css">
     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script>
     <script>document.addEventListener("DOMContentLoaded", () => hljs.initHighlightingOnLoad());</script>
   </head>
   <body>
     <section id="main"><h1>You Don't Know JS: ES6 &amp; Beyond</h1>
<h1>Chapter 7: Meta Programming</h1>
<p>Meta programming is programming where the operation targets the behavior of the program itself. In other words, it's programming the programming of your program. Yeah, a mouthful, huh?</p>
<p>For example, if you probe the relationship between one object <code>a</code> and another <code>b</code> -- are they <code>[[Prototype]]</code> linked? -- using <code>a.isPrototype(b)</code>, this is commonly referred to as introspection, a form of meta programming. Macros (which don't exist in JS, yet) --  where the code modifies itself at compile time -- are another obvious example of meta programming. Enumerating the keys of an object with a <code>for..in</code> loop, or checking if an object is an <em>instance of</em> a &quot;class constructor&quot;, are other common meta programming tasks.</p>
<p>Meta programming focuses on one or more of the following: code inspecting itself, code modifying itself, or code modifying default language behavior so other code is affected.</p>
<p>The goal of meta programming is to leverage the language's own intrinsic capabilities to make the rest of your code more descriptive, expressive, and/or flexible. Because of the <em>meta</em> nature of meta programming, it's somewhat difficult to put a more precise definition on it than that. The best way to understand meta programming is to see it through examples.</p>
<p>ES6 adds several new forms/features for meta programming on top of what JS already had.</p>
<h2>Function Names</h2>
<p>There are cases where your code may want to introspect on itself and ask what the name of some function is. If you ask what a function's name is, the answer is surprisingly somewhat ambiguous. Consider:</p>
<pre><code class="language-js">function daz() {
    // ..
}

var obj = {
    foo: function() {
        // ..
    },
    bar: function baz() {
        // ..
    },
    bam: daz,
    zim() {
        // ..
    }
};
</code></pre>
<p>In this previous snippet, &quot;what is the name of <code>obj.foo()</code>&quot; is slightly nuanced. Is it <code>&quot;foo&quot;</code>, <code>&quot;&quot;</code>, or <code>undefined</code>? And what about <code>obj.bar()</code> -- is it named <code>&quot;bar&quot;</code> or <code>&quot;baz&quot;</code>? Is <code>obj.bam()</code> named <code>&quot;bam&quot;</code> or <code>&quot;daz&quot;</code>? What about <code>obj.zim()</code>?</p>
<p>Moreover, what about functions which are passed as callbacks, like:</p>
<pre><code class="language-js">function foo(cb) {
    // what is the name of `cb()` here?
}

foo( function(){
    // I'm anonymous!
} );
</code></pre>
<p>There are quite a few ways that functions can be expressed in programs, and it's not always clear and unambiguous what the &quot;name&quot; of that function should be.</p>
<p>More importantly, we need to distinguish whether the &quot;name&quot; of a function refers to its <code>name</code> property -- yes, functions have a property called <code>name</code> -- or whether it refers to the lexical binding name, such as <code>bar</code> in <code>function bar() { .. }</code>.</p>
<p>The lexical binding name is what you use for things like recursion:</p>
<pre><code class="language-js">function foo(i) {
    if (i &lt; 10) return foo( i * 2 );
    return i;
}
</code></pre>
<p>The <code>name</code> property is what you'd use for meta programming purposes, so that's what we'll focus on in this discussion.</p>
<p>The confusion comes because by default, the lexical name a function has (if any) is also set as its <code>name</code> property. Actually there was no official requirement for that behavior by the ES5 (and prior) specifications. The setting of the <code>name</code> property was nonstandard but still fairly reliable. As of ES6, it has been standardized.</p>
<p><strong>Tip:</strong> If a function has a <code>name</code> value assigned, that's typically the name used in stack traces in developer tools.</p>
<h3>Inferences</h3>
<p>But what happens to the <code>name</code> property if a function has no lexical name?</p>
<p>As of ES6, there are now inference rules which can determine a sensible <code>name</code> property value to assign a function even if that function doesn't have a lexical name to use.</p>
<p>Consider:</p>
<pre><code class="language-js">var abc = function() {
    // ..
};

abc.name;               // &quot;abc&quot;
</code></pre>
<p>Had we given the function a lexical name like <code>abc = function def() { .. }</code>, the <code>name</code> property would of course be <code>&quot;def&quot;</code>. But in the absence of the lexical name, intuitively the <code>&quot;abc&quot;</code> name seems appropriate.</p>
<p>Here are other forms that will infer a name (or not) in ES6:</p>
<pre><code class="language-js">(function(){ .. });                 // name:
(function*(){ .. });                // name:
window.foo = function(){ .. };      // name:

class Awesome {
    constructor() { .. }            // name: Awesome
    funny() { .. }                  // name: funny
}

var c = class Awesome { .. };       // name: Awesome

var o = {
    foo() { .. },                   // name: foo
    *bar() { .. },                  // name: bar
    baz: () =&gt; { .. },              // name: baz
    bam: function(){ .. },          // name: bam
    get qux() { .. },               // name: get qux
    set fuz() { .. },               // name: set fuz
    [&quot;b&quot; + &quot;iz&quot;]:
        function(){ .. },           // name: biz
    [Symbol( &quot;buz&quot; )]:
        function(){ .. }            // name: [buz]
};

var x = o.foo.bind( o );            // name: bound foo
(function(){ .. }).bind( o );       // name: bound

export default function() { .. }    // name: default

var y = new Function();             // name: anonymous
var GeneratorFunction =
    function*(){}.__proto__.constructor;
var z = new GeneratorFunction();    // name: anonymous
</code></pre>
<p>The <code>name</code> property is not writable by default, but it is configurable, meaning you can use <code>Object.defineProperty(..)</code> to manually change it if so desired.</p>
<h2>Meta Properties</h2>
<p>In the &quot;<code>new.target</code>&quot; section of Chapter 3, we introduced a concept new to JS in ES6: the meta property. As the name suggests, meta properties are intended to provide special meta information in the form of a property access that would otherwise not have been possible.</p>
<p>In the case of <code>new.target</code>, the keyword <code>new</code> serves as the context for a property access. Clearly <code>new</code> is itself not an object, which makes this capability special. However, when <code>new.target</code> is used inside a constructor call (a function/method invoked with <code>new</code>), <code>new</code> becomes a virtual context, so that <code>new.target</code> can refer to the target constructor that <code>new</code> invoked.</p>
<p>This is a clear example of a meta programming operation, as the intent is to determine from inside a constructor call what the original <code>new</code> target was, generally for the purposes of introspection (examining typing/structure) or static property access.</p>
<p>For example, you may want to have different behavior in a constructor depending on if it's directly invoked or invoked via a child class:</p>
<pre><code class="language-js">class Parent {
    constructor() {
        if (new.target === Parent) {
            console.log( &quot;Parent instantiated&quot; );
        }
        else {
            console.log( &quot;A child instantiated&quot; );
        }
    }
}

class Child extends Parent {}

var a = new Parent();
// Parent instantiated

var b = new Child();
// A child instantiated
</code></pre>
<p>There's a slight nuance here, which is that the <code>constructor()</code> inside the <code>Parent</code> class definition is actually given the lexical name of the class (<code>Parent</code>), even though the syntax implies that the class is a separate entity from the constructor.</p>
<p><strong>Warning:</strong> As with all meta programming techniques, be careful of creating code that's too clever for your future self or others maintaining your code to understand. Use these tricks with caution.</p>
<h2>Well Known Symbols</h2>
<p>In the &quot;Symbols&quot; section of Chapter 2, we covered the new ES6 primitive type <code>symbol</code>. In addition to symbols you can define in your own program, JS predefines a number of built-in symbols, referred to as <em>Well Known Symbols</em> (WKS).</p>
<p>These symbol values are defined primarily to expose special meta properties that are being exposed to your JS programs to give you more control over JS's behavior.</p>
<p>We'll briefly introduce each and discuss their purpose.</p>
<h3><code>Symbol.iterator</code></h3>
<p>In Chapters 2 and 3, we introduced and used the <code>@@iterator</code> symbol, automatically used by <code>...</code> spreads and <code>for..of</code> loops. We also saw <code>@@iterator</code> as defined on the new ES6 collections as defined in Chapter 5.</p>
<p><code>Symbol.iterator</code> represents the special location (property) on any object where the language mechanisms automatically look to find a method that will construct an iterator instance for consuming that object's values. Many objects come with a default one defined.</p>
<p>However, we can define our own iterator logic for any object value by setting the <code>Symbol.iterator</code> property, even if that's overriding the default iterator. The meta programming aspect is that we are defining behavior which other parts of JS (namely, operators and looping constructs) use when processing an object value we define.</p>
<p>Consider:</p>
<pre><code class="language-js">var arr = [4,5,6,7,8,9];

for (var v of arr) {
    console.log( v );
}
// 4 5 6 7 8 9

// define iterator that only produces values
// from odd indexes
arr[Symbol.iterator] = function*() {
    var idx = 1;
    do {
        yield this[idx];
    } while ((idx += 2) &lt; this.length);
};

for (var v of arr) {
    console.log( v );
}
// 5 7 9
</code></pre>
<h3><code>Symbol.toStringTag</code> and <code>Symbol.hasInstance</code></h3>
<p>One of the most common meta programming tasks is to introspect on a value to find out what <em>kind</em> it is, usually to decide what operations are appropriate to perform on it. With objects, the two most common inspection techniques are <code>toString()</code> and <code>instanceof</code>.</p>
<p>Consider:</p>
<pre><code class="language-js">function Foo() {}

var a = new Foo();

a.toString();               // [object Object]
a instanceof Foo;           // true
</code></pre>
<p>As of ES6, you can control the behavior of these operations:</p>
<pre><code class="language-js">function Foo(greeting) {
    this.greeting = greeting;
}

Foo.prototype[Symbol.toStringTag] = &quot;Foo&quot;;

Object.defineProperty( Foo, Symbol.hasInstance, {
    value: function(inst) {
        return inst.greeting == &quot;hello&quot;;
    }
} );

var a = new Foo( &quot;hello&quot; ),
    b = new Foo( &quot;world&quot; );

b[Symbol.toStringTag] = &quot;cool&quot;;

a.toString();               // [object Foo]
String( b );                // [object cool]

a instanceof Foo;           // true
b instanceof Foo;           // false
</code></pre>
<p>The <code>@@toStringTag</code> symbol on the prototype (or instance itself) specifies a string value to use in the <code>[object ___]</code> stringification.</p>
<p>The <code>@@hasInstance</code> symbol is a method on the constructor function which receives the instance object value and lets you decide by returning <code>true</code> or <code>false</code> if the value should be considered an instance or not.</p>
<p><strong>Note:</strong> To set <code>@@hasInstance</code> on a function, you must use <code>Object.defineProperty(..)</code>, as the default one on <code>Function.prototype</code> is <code>writable: false</code>. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</p>
<h3><code>Symbol.species</code></h3>
<p>In &quot;Classes&quot; in Chapter 3, we introduced the <code>@@species</code> symbol, which controls which constructor is used by built-in methods of a class that needs to spawn new instances.</p>
<p>The most common example is when subclassing <code>Array</code> and wanting to define which constructor (<code>Array(..)</code> or your subclass) inherited methods like <code>slice(..)</code> should use. By default, <code>slice(..)</code> called on an instance of a subclass of <code>Array</code> would produce a new instance of that subclass, which is frankly what you'll likely often want.</p>
<p>However, you can meta program by overriding a class's default <code>@@species</code> definition:</p>
<pre><code class="language-js">class Cool {
    // defer `@@species` to derived constructor
    static get [Symbol.species]() { return this; }

    again() {
        return new this.constructor[Symbol.species]();
    }
}

class Fun extends Cool {}

class Awesome extends Cool {
    // force `@@species` to be parent constructor
    static get [Symbol.species]() { return Cool; }
}

var a = new Fun(),
    b = new Awesome(),
    c = a.again(),
    d = b.again();

c instanceof Fun;           // true
d instanceof Awesome;       // false
d instanceof Cool;          // true
</code></pre>
<p>The <code>Symbol.species</code> setting defaults on the built-in native constructors to the <code>return this</code> behavior as illustrated in the previous snippet in the <code>Cool</code> definition. It has no default on user classes, but as shown that behavior is easy to emulate.</p>
<p>If you need to define methods that generate new instances, use the meta programming of the <code>new this.constructor[Symbol.species](..)</code> pattern instead of the hard-wiring of <code>new this.constructor(..)</code> or <code>new XYZ(..)</code>. Derived classes will then be able to customize <code>Symbol.species</code> to control which constructor vends those instances.</p>
<h3><code>Symbol.toPrimitive</code></h3>
<p>In the <em>Types &amp; Grammar</em> title of this series, we discussed the <code>ToPrimitive</code> abstract coercion operation, which is used when an object must be coerced to a primitive value for some operation (such as <code>==</code> comparison or <code>+</code> addition). Prior to ES6, there was no way to control this behavior.</p>
<p>As of ES6, the <code>@@toPrimitive</code> symbol as a property on any object value can customize that <code>ToPrimitive</code> coercion by specifying a method.</p>
<p>Consider:</p>
<pre><code class="language-js">var arr = [1,2,3,4,5];

arr + 10;               // 1,2,3,4,510

arr[Symbol.toPrimitive] = function(hint) {
    if (hint == &quot;default&quot; || hint == &quot;number&quot;) {
        // sum all numbers
        return this.reduce( function(acc,curr){
            return acc + curr;
        }, 0 );
    }
};

arr + 10;               // 25
</code></pre>
<p>The <code>Symbol.toPrimitive</code> method will be provided with a <em>hint</em> of <code>&quot;string&quot;</code>, <code>&quot;number&quot;</code>, or <code>&quot;default&quot;</code> (which should be interpreted as <code>&quot;number&quot;</code>), depending on what type the operation invoking <code>ToPrimitive</code> is expecting. In the previous snippet, the additive <code>+</code> operation has no hint (<code>&quot;default&quot;</code> is passed). A multiplicative <code>*</code> operation would hint <code>&quot;number&quot;</code> and a <code>String(arr)</code> would hint <code>&quot;string&quot;</code>.</p>
<p><strong>Warning:</strong> The <code>==</code> operator will invoke the <code>ToPrimitive</code> operation with no hint -- the <code>@@toPrimitive</code> method, if any is called with hint <code>&quot;default&quot;</code> -- on an object if the other value being compared is not an object. However, if both comparison values are objects, the behavior of <code>==</code> is identical to <code>===</code>, which is that the references themselves are directly compared. In this case, <code>@@toPrimitive</code> is not invoked at all. See the <em>Types &amp; Grammar</em> title of this series for more information about coercion and the abstract operations.</p>
<h3>Regular Expression Symbols</h3>
<p>There are four well known symbols that can be overridden for regular expression objects, which control how those regular expressions are used by the four corresponding <code>String.prototype</code> functions of the same name:</p>
<ul>
<li><p><code>@@match</code>: The <code>Symbol.match</code> value of a regular expression is the method used to match all or part of a string value with the given regular expression. It's used by <code>String.prototype.match(..)</code> if you pass it a regular expression for the pattern matching.</p>
<p>The default algorithm for matching is laid out in section 21.2.5.6 of the ES6 specification (https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@match). You could override this default algorithm and provide extra regex features, such as look-behind assertions.</p>
<p><code>Symbol.match</code> is also used by the <code>isRegExp</code> abstract operation (see the note in &quot;String Inspection Functions&quot; in Chapter 6) to determine if an object is intended to be used as a regular expression. To force this check to fail for an object so it's not treated as a regular expression, set the <code>Symbol.match</code> value to <code>false</code> (or something falsy).</p></li>
<li><p><code>@@replace</code>: The <code>Symbol.replace</code> value of a regular expression is the method used by <code>String.prototype.replace(..)</code> to replace within a string one or all occurrences of character sequences that match the given regular expression pattern.</p>
<p>The default algorithm for replacing is laid out in section 21.2.5.8 of the ES6 specification (https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@replace).</p>
<p>One cool use for overriding the default algorithm is to provide additional <code>replacer</code> argument options, such as supporting <code>&quot;abaca&quot;.replace(/a/g,[1,2,3])</code> producing <code>&quot;1b2c3&quot;</code> by consuming the iterable for successive replacement values.</p></li>
<li><p><code>@@search</code>: The <code>Symbol.search</code> value of a regular expression is the method used by <code>String.prototype.search(..)</code> to search for a sub-string within another string as matched by the given regular expression.</p>
<p>The default algorithm for searching is laid out in section 21.2.5.9 of the ES6 specification (https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@search).</p></li>
<li><p><code>@@split</code>: The <code>Symbol.split</code> value of a regular expression is the method used by <code>String.prototype.split(..)</code> to split a string into sub-strings at the location(s) of the delimiter as matched by the given regular expression.</p>
<p>The default algorithm for splitting is laid out in section 21.2.5.11 of the ES6 specification (https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@split).</p></li>
</ul>
<p>Overriding the built-in regular expression algorithms is not for the faint of heart! JS ships with a highly optimized regular expression engine, so your own user code will likely be a lot slower. This kind of meta programming is neat and powerful, but it should only be used in cases where it's really necessary or beneficial.</p>
<h3><code>Symbol.isConcatSpreadable</code></h3>
<p>The <code>@@isConcatSpreadable</code> symbol can be defined as a boolean property (<code>Symbol.isConcatSpreadable</code>) on any object (like an array or other iterable) to indicate if it should be <em>spread out</em> if passed to an array <code>concat(..)</code>.</p>
<p>Consider:</p>
<pre><code class="language-js">var a = [1,2,3],
    b = [4,5,6];

b[Symbol.isConcatSpreadable] = false;

[].concat( a, b );      // [1,2,3,[4,5,6]]
</code></pre>
<h3><code>Symbol.unscopables</code></h3>
<p>The <code>@@unscopables</code> symbol can be defined as an object property (<code>Symbol.unscopables</code>) on any object to indicate which properties can and cannot be exposed as lexical variables in a <code>with</code> statement.</p>
<p>Consider:</p>
<pre><code class="language-js">var o = { a:1, b:2, c:3 },
    a = 10, b = 20, c = 30;

o[Symbol.unscopables] = {
    a: false,
    b: true,
    c: false
};

with (o) {
    console.log( a, b, c );     // 1 20 3
}
</code></pre>
<p>A <code>true</code> in the <code>@@unscopables</code> object indicates the property should be <em>unscopable</em>, and thus filtered out from the lexical scope variables. <code>false</code> means it's OK to be included in the lexical scope variables.</p>
<p><strong>Warning:</strong> The <code>with</code> statement is disallowed entirely in <code>strict</code> mode, and as such should be considered deprecated from the language. Don't use it. See the <em>Scope &amp; Closures</em> title of this series for more information. Because <code>with</code> should be avoided, the <code>@@unscopables</code> symbol is also moot.</p>
<h2>Proxies</h2>
<p>One of the most obviously meta programming features added to ES6 is the <code>Proxy</code> feature.</p>
<p>A proxy is a special kind of object you create that &quot;wraps&quot; -- or sits in front of -- another normal object. You can register special handlers (aka <em>traps</em>) on the proxy object which are called when various operations are performed against the proxy. These handlers have the opportunity to perform extra logic in addition to <em>forwarding</em> the operations on to the original target/wrapped object.</p>
<p>One example of the kind of <em>trap</em> handler you can define on a proxy is <code>get</code> that intercepts the <code>[[Get]]</code> operation -- performed when you try to access a property on an object. Consider:</p>
<pre><code class="language-js">var obj = { a: 1 },
    handlers = {
        get(target,key,context) {
            // note: target === obj,
            // context === pobj
            console.log( &quot;accessing: &quot;, key );
            return Reflect.get(
                target, key, context
            );
        }
    },
    pobj = new Proxy( obj, handlers );

obj.a;
// 1

pobj.a;
// accessing: a
// 1
</code></pre>
<p>We declare a <code>get(..)</code> handler as a named method on the <em>handler</em> object (second argument to <code>Proxy(..)</code>), which receives a reference to the <em>target</em> object (<code>obj</code>), the <em>key</em> property name (<code>&quot;a&quot;</code>), and the <code>self</code>/receiver/proxy (<code>pobj</code>).</p>
<p>After the <code>console.log(..)</code> tracing statement, we &quot;forward&quot; the operation onto <code>obj</code> via <code>Reflect.get(..)</code>. We will cover the <code>Reflect</code> API in the next section, but note that each available proxy trap has a corresponding <code>Reflect</code> function of the same name.</p>
<p>These mappings are symmetric on purpose. The proxy handlers each intercept when a respective meta programming task is performed, and the <code>Reflect</code> utilities each perform the respective meta programming task on an object. Each proxy handler has a default definition that automatically calls the corresponding <code>Reflect</code> utility. You will almost certainly use both <code>Proxy</code> and <code>Reflect</code> in tandem.</p>
<p>Here's a list of handlers you can define on a proxy for a <em>target</em> object/function, and how/when they are triggered:</p>
<ul>
<li><code>get(..)</code>: via <code>[[Get]]</code>, a property is accessed on the proxy (<code>Reflect.get(..)</code>, <code>.</code> property operator, or <code>[ .. ]</code> property operator)</li>
<li><code>set(..)</code>: via <code>[[Set]]</code>, a property value is set on the proxy (<code>Reflect.set(..)</code>, the <code>=</code> assignment operator, or destructuring assignment if it targets an object property)</li>
<li><code>deleteProperty(..)</code>: via <code>[[Delete]]</code>, a property is deleted from the proxy (<code>Reflect.deleteProperty(..)</code> or <code>delete</code>)</li>
<li><code>apply(..)</code> (if <em>target</em> is a function): via <code>[[Call]]</code>, the proxy is invoked as a normal function/method (<code>Reflect.apply(..)</code>, <code>call(..)</code>, <code>apply(..)</code>, or the <code>(..)</code> call operator)</li>
<li><code>construct(..)</code> (if <em>target</em> is a constructor function): via <code>[[Construct]]</code>, the proxy is invoked as a constructor function (<code>Reflect.construct(..)</code> or <code>new</code>)</li>
<li><code>getOwnPropertyDescriptor(..)</code>: via <code>[[GetOwnProperty]]</code>, a property descriptor is retrieved from the proxy (<code>Object.getOwnPropertyDescriptor(..)</code> or <code>Reflect.getOwnPropertyDescriptor(..)</code>)</li>
<li><code>defineProperty(..)</code>: via <code>[[DefineOwnProperty]]</code>, a property descriptor is set on the proxy (<code>Object.defineProperty(..)</code> or <code>Reflect.defineProperty(..)</code>)</li>
<li><code>getPrototypeOf(..)</code>: via <code>[[GetPrototypeOf]]</code>, the <code>[[Prototype]]</code> of the proxy is retrieved (<code>Object.getPrototypeOf(..)</code>, <code>Reflect.getPrototypeOf(..)</code>, <code>__proto__</code>, <code>Object#isPrototypeOf(..)</code>, or <code>instanceof</code>)</li>
<li><code>setPrototypeOf(..)</code>: via <code>[[SetPrototypeOf]]</code>, the <code>[[Prototype]]</code> of the proxy is set (<code>Object.setPrototypeOf(..)</code>, <code>Reflect.setPrototypeOf(..)</code>, or <code>__proto__</code>)</li>
<li><code>preventExtensions(..)</code>: via <code>[[PreventExtensions]]</code>, the proxy is made non-extensible (<code>Object.preventExtensions(..)</code> or <code>Reflect.preventExtensions(..)</code>)</li>
<li><code>isExtensible(..)</code>: via <code>[[IsExtensible]]</code>, the extensibility of the proxy is probed (<code>Object.isExtensible(..)</code> or <code>Reflect.isExtensible(..)</code>)</li>
<li><code>ownKeys(..)</code>: via <code>[[OwnPropertyKeys]]</code>, the set of owned properties and/or owned symbol properties of the proxy is retrieved (<code>Object.keys(..)</code>, <code>Object.getOwnPropertyNames(..)</code>, <code>Object.getOwnSymbolProperties(..)</code>, <code>Reflect.ownKeys(..)</code>, or <code>JSON.stringify(..)</code>)</li>
<li><code>enumerate(..)</code>: via <code>[[Enumerate]]</code>, an iterator is requested for the proxy's enumerable owned and &quot;inherited&quot; properties (<code>Reflect.enumerate(..)</code> or <code>for..in</code>)</li>
<li><code>has(..)</code>: via <code>[[HasProperty]]</code>, the proxy is probed to see if it has an owned or &quot;inherited&quot; property (<code>Reflect.has(..)</code>, <code>Object#hasOwnProperty(..)</code>, or <code>&quot;prop&quot; in obj</code>)</li>
</ul>
<p><strong>Tip:</strong> For more information about each of these meta programming tasks, see the &quot;<code>Reflect</code> API&quot; section later in this chapter.</p>
<p>In addition to the notations in the preceding list about actions that will trigger the various traps, some traps are triggered indirectly by the default actions of another trap. For example:</p>
<pre><code class="language-js">var handlers = {
        getOwnPropertyDescriptor(target,prop) {
            console.log(
                &quot;getOwnPropertyDescriptor&quot;
            );
            return Object.getOwnPropertyDescriptor(
                target, prop
            );
        },
        defineProperty(target,prop,desc){
            console.log( &quot;defineProperty&quot; );
            return Object.defineProperty(
                target, prop, desc
            );
        }
    },
    proxy = new Proxy( {}, handlers );

proxy.a = 2;
// getOwnPropertyDescriptor
// defineProperty
</code></pre>
<p>The <code>getOwnPropertyDescriptor(..)</code> and <code>defineProperty(..)</code> handlers are triggered by the default <code>set(..)</code> handler's steps when setting a property value (whether newly adding or updating). If you also define your own <code>set(..)</code> handler, you may or may not make the corresponding calls against <code>context</code> (not <code>target</code>!) which would trigger these proxy traps.</p>
<h3>Proxy Limitations</h3>
<p>These meta programming handlers trap a wide array of fundamental operations you can perform against an object. However, there are some operations which are not (yet, at least) available to intercept.</p>
<p>For example, none of these operations are trapped and forwarded from <code>pobj</code> proxy to <code>obj</code> target:</p>
<pre><code class="language-js">var obj = { a:1, b:2 },
    handlers = { .. },
    pobj = new Proxy( obj, handlers );

typeof obj;
String( obj );
obj + &quot;&quot;;
obj == pobj;
obj === pobj
</code></pre>
<p>Perhaps in the future, more of these underlying fundamental operations in the language will be interceptable, giving us even more power to extend JavaScript from within itself.</p>
<p><strong>Warning:</strong> There are certain <em>invariants</em> -- behaviors which cannot be overridden -- that apply to the use of proxy handlers. For example, the result from the <code>isExtensible(..)</code> handler is always coerced to a <code>boolean</code>. These invariants restrict some of your ability to customize behaviors with proxies, but they do so only to prevent you from creating strange and unusual (or inconsistent) behavior. The conditions for these invariants are complicated so we won't fully go into them here, but this post (http://www.2ality.com/2014/12/es6-proxies.html#invariants) does a great job of covering them.</p>
<h3>Revocable Proxies</h3>
<p>A regular proxy always traps for the target object, and cannot be modified after creation -- as long as a reference is kept to the proxy, proxying remains possible. However, there may be cases where you want to create a proxy that can be disabled when you want to stop allowing it to proxy. The solution is to create a <em>revocable proxy</em>:</p>
<pre><code class="language-js">var obj = { a: 1 },
    handlers = {
        get(target,key,context) {
            // note: target === obj,
            // context === pobj
            console.log( &quot;accessing: &quot;, key );
            return target[key];
        }
    },
    { proxy: pobj, revoke: prevoke } =
        Proxy.revocable( obj, handlers );

pobj.a;
// accessing: a
// 1

// later:
prevoke();

pobj.a;
// TypeError
</code></pre>
<p>A revocable proxy is created with <code>Proxy.revocable(..)</code>, which is a regular function, not a constructor like <code>Proxy(..)</code>. Otherwise, it takes the same two arguments: <em>target</em> and <em>handlers</em>.</p>
<p>The return value of <code>Proxy.revocable(..)</code> is not the proxy itself as with <code>new Proxy(..)</code>. Instead, it's an object with two properties: <em>proxy</em> and <em>revoke</em> -- we used object destructuring (see &quot;Destructuring&quot; in Chapter 2) to assign these properties to <code>pobj</code> and <code>prevoke()</code> variables, respectively.</p>
<p>Once a revocable proxy is revoked, any attempts to access it (trigger any of its traps) will throw a <code>TypeError</code>.</p>
<p>An example of using a revocable proxy might be handing out a proxy to another party in your application that manages data in your model, instead of giving them a reference to the real model object itself. If your model object changes or is replaced, you want to invalidate the proxy you handed out so the other party knows (via the errors!) to request an updated reference to the model.</p>
<h3>Using Proxies</h3>
<p>The meta programming benefits of these Proxy handlers should be obvious. We can almost fully intercept (and thus override) the behavior of objects, meaning we can extend object behavior beyond core JS in some very powerful ways. We'll look at a few example patterns to explore the possibilities.</p>
<h4>Proxy First, Proxy Last</h4>
<p>As we mentioned earlier, you typically think of a proxy as &quot;wrapping&quot; the target object. In that sense, the proxy becomes the primary object that the code interfaces with, and the actual target object remains hidden/protected.</p>
<p>You might do this because you want to pass the object somewhere that can't be fully &quot;trusted,&quot; and so you need to enforce special rules around its access rather than passing the object itself.</p>
<p>Consider:</p>
<pre><code class="language-js">var messages = [],
    handlers = {
        get(target,key) {
            // string value?
            if (typeof target[key] == &quot;string&quot;) {
                // filter out punctuation
                return target[key]
                    .replace( /[^\w]/g, &quot;&quot; );
            }

            // pass everything else through
            return target[key];
        },
        set(target,key,val) {
            // only set unique strings, lowercased
            if (typeof val == &quot;string&quot;) {
                val = val.toLowerCase();
                if (target.indexOf( val ) == -1) {
                    target.push(
                        val.toLowerCase()
                    );
                }
            }
            return true;
        }
    },
    messages_proxy =
        new Proxy( messages, handlers );

// elsewhere:
messages_proxy.push(
    &quot;heLLo...&quot;, 42, &quot;wOrlD!!&quot;, &quot;WoRld!!&quot;
);

messages_proxy.forEach( function(val){
    console.log(val);
} );
// hello world

messages.forEach( function(val){
    console.log(val);
} );
// hello... world!!
</code></pre>
<p>I call this <em>proxy first</em> design, as we interact first (primarily, entirely) with the proxy.</p>
<p>We enforce some special rules on interacting with <code>messages_proxy</code> that aren't enforced for <code>messages</code> itself. We only add elements if the value is a string and is also unique; we also lowercase the value. When retrieving values from <code>messages_proxy</code>, we filter out any punctuation in the strings.</p>
<p>Alternatively, we can completely invert this pattern, where the target interacts with the proxy instead of the proxy interacting with the target. Thus, code really only interacts with the main object. The easiest way to accomplish this fallback is to have the proxy object in the <code>[[Prototype]]</code> chain of the main object.</p>
<p>Consider:</p>
<pre><code class="language-js">var handlers = {
        get(target,key,context) {
            return function() {
                context.speak(key + &quot;!&quot;);
            };
        }
    },
    catchall = new Proxy( {}, handlers ),
    greeter = {
        speak(who = &quot;someone&quot;) {
            console.log( &quot;hello&quot;, who );
        }
    };

// setup `greeter` to fall back to `catchall`
Object.setPrototypeOf( greeter, catchall );

greeter.speak();                // hello someone
greeter.speak( &quot;world&quot; );       // hello world

greeter.everyone();             // hello everyone!
</code></pre>
<p>We interact directly with <code>greeter</code> instead of <code>catchall</code>. When we call <code>speak(..)</code>, it's found on <code>greeter</code> and used directly. But when we try to access a method like <code>everyone()</code>, that function doesn't exist on <code>greeter</code>.</p>
<p>The default object property behavior is to check up the <code>[[Prototype]]</code> chain (see the <em>this &amp; Object Prototypes</em> title of this series), so <code>catchall</code> is consulted for an <code>everyone</code> property. The proxy <code>get()</code> handler then kicks in and returns a function that calls <code>speak(..)</code> with the name of the property being accessed (<code>&quot;everyone&quot;</code>).</p>
<p>I call this pattern <em>proxy last</em>, as the proxy is used only as a last resort.</p>
<h4>&quot;No Such Property/Method&quot;</h4>
<p>A common complaint about JS is that objects aren't by default very defensive in the situation where you try to access or set a property that doesn't already exist. You may wish to predefine all the properties/methods for an object, and have an error thrown if a nonexistent property name is subsequently used.</p>
<p>We can accomplish this with a proxy, either in <em>proxy first</em> or <em>proxy last</em> design. Let's consider both.</p>
<pre><code class="language-js">var obj = {
        a: 1,
        foo() {
            console.log( &quot;a:&quot;, this.a );
        }
    },
    handlers = {
        get(target,key,context) {
            if (Reflect.has( target, key )) {
                return Reflect.get(
                    target, key, context
                );
            }
            else {
                throw &quot;No such property/method!&quot;;
            }
        },
        set(target,key,val,context) {
            if (Reflect.has( target, key )) {
                return Reflect.set(
                    target, key, val, context
                );
            }
            else {
                throw &quot;No such property/method!&quot;;
            }
        }
    },
    pobj = new Proxy( obj, handlers );

pobj.a = 3;
pobj.foo();         // a: 3

pobj.b = 4;         // Error: No such property/method!
pobj.bar();         // Error: No such property/method!
</code></pre>
<p>For both <code>get(..)</code> and <code>set(..)</code>, we only forward the operation if the target object's property already exists; error thrown otherwise. The proxy object (<code>pobj</code>) is the main object code should interact with, as it intercepts these actions to provide the protections.</p>
<p>Now, let's consider inverting with <em>proxy last</em> design:</p>
<pre><code class="language-js">var handlers = {
        get() {
            throw &quot;No such property/method!&quot;;
        },
        set() {
            throw &quot;No such property/method!&quot;;
        }
    },
    pobj = new Proxy( {}, handlers ),
    obj = {
        a: 1,
        foo() {
            console.log( &quot;a:&quot;, this.a );
        }
    };

// setup `obj` to fall back to `pobj`
Object.setPrototypeOf( obj, pobj );

obj.a = 3;
obj.foo();          // a: 3

obj.b = 4;          // Error: No such property/method!
obj.bar();          // Error: No such property/method!
</code></pre>
<p>The <em>proxy last</em> design here is a fair bit simpler with respect to how the handlers are defined. Instead of needing to intercept the <code>[[Get]]</code> and <code>[[Set]]</code> operations and only forward them if the target property exists, we instead rely on the fact that if either <code>[[Get]]</code> or <code>[[Set]]</code> get to our <code>pobj</code> fallback, the action has already traversed the whole <code>[[Prototype]]</code> chain and not found a matching property. We are free at that point to unconditionally throw the error. Cool, huh?</p>
<h4>Proxy Hacking the <code>[[Prototype]]</code> Chain</h4>
<p>The <code>[[Get]]</code> operation is the primary channel by which the <code>[[Prototype]]</code> mechanism is invoked. When a property is not found on the immediate object, <code>[[Get]]</code> automatically hands off the operation to the <code>[[Prototype]]</code> object.</p>
<p>That means you can use the <code>get(..)</code> trap of a proxy to emulate or extend the notion of this <code>[[Prototype]]</code> mechanism.</p>
<p>The first hack we'll consider is creating two objects which are circularly linked via <code>[[Prototype]]</code> (or, at least it appears that way!). You cannot actually create a real circular <code>[[Prototype]]</code> chain, as the engine will throw an error. But a proxy can fake it!</p>
<p>Consider:</p>
<pre><code class="language-js">var handlers = {
        get(target,key,context) {
            if (Reflect.has( target, key )) {
                return Reflect.get(
                    target, key, context
                );
            }
            // fake circular `[[Prototype]]`
            else {
                return Reflect.get(
                    target[
                        Symbol.for( &quot;[[Prototype]]&quot; )
                    ],
                    key,
                    context
                );
            }
        }
    },
    obj1 = new Proxy(
        {
            name: &quot;obj-1&quot;,
            foo() {
                console.log( &quot;foo:&quot;, this.name );
            }
        },
        handlers
    ),
    obj2 = Object.assign(
        Object.create( obj1 ),
        {
            name: &quot;obj-2&quot;,
            bar() {
                console.log( &quot;bar:&quot;, this.name );
                this.foo();
            }
        }
    );

// fake circular `[[Prototype]]` link
obj1[ Symbol.for( &quot;[[Prototype]]&quot; ) ] = obj2;

obj1.bar();
// bar: obj-1 &lt;-- through proxy faking [[Prototype]]
// foo: obj-1 &lt;-- `this` context still preserved

obj2.foo();
// foo: obj-2 &lt;-- through [[Prototype]]
</code></pre>
<p><strong>Note:</strong> We didn't need to proxy/forward <code>[[Set]]</code> in this example, so we kept things simpler. To be fully <code>[[Prototype]]</code> emulation compliant, you'd want to implement a <code>set(..)</code> handler that searches the <code>[[Prototype]]</code> chain for a matching property and respects its descriptor behavior (e.g., set, writable). See the <em>this &amp; Object Prototypes</em> title of this series.</p>
<p>In the previous snippet, <code>obj2</code> is <code>[[Prototype]]</code> linked to <code>obj1</code> by virtue of the <code>Object.create(..)</code> statement. But to create the reverse (circular) linkage, we create property on <code>obj1</code> at the symbol location <code>Symbol.for(&quot;[[Prototype]]&quot;)</code> (see &quot;Symbols&quot; in Chapter 2). This symbol may look sort of special/magical, but it isn't. It just allows me a conveniently named hook that semantically appears related to the task I'm performing.</p>
<p>Then, the proxy's <code>get(..)</code> handler looks first to see if a requested <code>key</code> is on the proxy. If not, the operation is manually handed off to the object reference stored in the <code>Symbol.for(&quot;[[Prototype]]&quot;)</code> location of <code>target</code>.</p>
<p>One important advantage of this pattern is that the definitions of <code>obj1</code> and <code>obj2</code> are mostly not intruded by the setting up of this circular relationship between them. Although the previous snippet has all the steps intertwined for brevity's sake, if you look closely, the proxy handler logic is entirely generic (doesn't know about <code>obj1</code> or <code>obj2</code> specifically). So, that logic could be pulled out into a simple helper that wires them up, like a <code>setCircularPrototypeOf(..)</code> for example. We'll leave that as an exercise for the reader.</p>
<p>Now that we've seen how we can use <code>get(..)</code> to emulate a <code>[[Prototype]]</code> link, let's push the hackery a bit further. Instead of a circular <code>[[Prototype]]</code>, what about multiple <code>[[Prototype]]</code> linkages (aka &quot;multiple inheritance&quot;)? This turns out to be fairly straightforward:</p>
<pre><code class="language-js">var obj1 = {
        name: &quot;obj-1&quot;,
        foo() {
            console.log( &quot;obj1.foo:&quot;, this.name );
        },
    },
    obj2 = {
        name: &quot;obj-2&quot;,
        foo() {
            console.log( &quot;obj2.foo:&quot;, this.name );
        },
        bar() {
            console.log( &quot;obj2.bar:&quot;, this.name );
        }
    },
    handlers = {
        get(target,key,context) {
            if (Reflect.has( target, key )) {
                return Reflect.get(
                    target, key, context
                );
            }
            // fake multiple `[[Prototype]]`
            else {
                for (var P of target[
                    Symbol.for( &quot;[[Prototype]]&quot; )
                ]) {
                    if (Reflect.has( P, key )) {
                        return Reflect.get(
                            P, key, context
                        );
                    }
                }
            }
        }
    },
    obj3 = new Proxy(
        {
            name: &quot;obj-3&quot;,
            baz() {
                this.foo();
                this.bar();
            }
        },
        handlers
    );

// fake multiple `[[Prototype]]` links
obj3[ Symbol.for( &quot;[[Prototype]]&quot; ) ] = [
    obj1, obj2
];

obj3.baz();
// obj1.foo: obj-3
// obj2.bar: obj-3
</code></pre>
<p><strong>Note:</strong> As mentioned in the note after the earlier circular <code>[[Prototype]]</code> example, we didn't implement the <code>set(..)</code> handler, but it would be necessary for a complete solution that emulates <code>[[Set]]</code> actions as normal <code>[[Prototype]]</code>s behave.</p>
<p><code>obj3</code> is set up to multiple-delegate to both <code>obj1</code> and <code>obj2</code>. In <code>obj3.baz()</code>, the <code>this.foo()</code> call ends up pulling <code>foo()</code> from <code>obj1</code> (first-come, first-served, even though there's also a <code>foo()</code> on <code>obj2</code>). If we reordered the linkage as <code>obj2, obj1</code>, the <code>obj2.foo()</code> would have been found and used.</p>
<p>But as is, the <code>this.bar()</code> call doesn't find a <code>bar()</code> on <code>obj1</code>, so it falls over to check <code>obj2</code>, where it finds a match.</p>
<p><code>obj1</code> and <code>obj2</code> represent two parallel <code>[[Prototype]]</code> chains of <code>obj3</code>. <code>obj1</code> and/or <code>obj2</code> could themselves have normal <code>[[Prototype]]</code> delegation to other objects, or either could themself be a proxy (like <code>obj3</code> is) that can multiple-delegate.</p>
<p>Just as with the circular <code>[[Prototype]]</code> example earlier, the definitions of <code>obj1</code>, <code>obj2</code>, and <code>obj3</code> are almost entirely separate from the generic proxy logic that handles the multiple-delegation. It would be trivial to define a utility like <code>setPrototypesOf(..)</code> (notice the &quot;s&quot;!) that takes a main object and a list of objects to fake the multiple <code>[[Prototype]]</code> linkage to. Again, we'll leave that as an exercise for the reader.</p>
<p>Hopefully the power of proxies is now becoming clearer after these various examples. There are many other powerful meta programming tasks that proxies enable.</p>
<h2><code>Reflect</code> API</h2>
<p>The <code>Reflect</code> object is a plain object (like <code>Math</code>), not a function/constructor like the other built-in natives.</p>
<p>It holds static functions which correspond to various meta programming tasks that you can control. These functions correspond one-to-one with the handler methods (<em>traps</em>) that Proxies can define.</p>
<p>Some of the functions will look familiar as functions of the same names on <code>Object</code>:</p>
<ul>
<li><code>Reflect.getOwnPropertyDescriptor(..)</code></li>
<li><code>Reflect.defineProperty(..)</code></li>
<li><code>Reflect.getPrototypeOf(..)</code></li>
<li><code>Reflect.setPrototypeOf(..)</code></li>
<li><code>Reflect.preventExtensions(..)</code></li>
<li><code>Reflect.isExtensible(..)</code></li>
</ul>
<p>These utilities in general behave the same as their <code>Object.*</code> counterparts. However, one difference is that the <code>Object.*</code> counterparts attempt to coerce their first argument (the target object) to an object if it's not already one. The <code>Reflect.*</code> methods simply throw an error in that case.</p>
<p>An object's keys can be accessed/inspected using these utilities:</p>
<ul>
<li><code>Reflect.ownKeys(..)</code>: Returns the list of all owned keys (not &quot;inherited&quot;), as returned by both <code>Object.getOwnPropertyNames(..)</code> and <code>Object.getOwnPropertySymbols(..)</code>. See the &quot;Property Enumeration Order&quot; section for information about the order of keys.</li>
<li><code>Reflect.enumerate(..)</code>: Returns an iterator that produces the set of all non-symbol keys (owned and &quot;inherited&quot;) that are <em>enumerable</em> (see the <em>this &amp; Object Prototypes</em> title of this series). Essentially, this set of keys is the same as those processed by a <code>for..in</code> loop. See the &quot;Property Enumeration Order&quot; section for information about the order of keys.</li>
<li><code>Reflect.has(..)</code>: Essentially the same as the <code>in</code> operator for checking if a property is on an object or its <code>[[Prototype]]</code> chain. For example, <code>Reflect.has(o,&quot;foo&quot;)</code> essentially performs <code>&quot;foo&quot; in o</code>.</li>
</ul>
<p>Function calls and constructor invocations can be performed manually, separate of the normal syntax (e.g., <code>(..)</code> and <code>new</code>) using these utilities:</p>
<ul>
<li><code>Reflect.apply(..)</code>: For example, <code>Reflect.apply(foo,thisObj,[42,&quot;bar&quot;])</code> calls the <code>foo(..)</code> function with <code>thisObj</code> as its <code>this</code>, and passes in the <code>42</code> and <code>&quot;bar&quot;</code> arguments.</li>
<li><code>Reflect.construct(..)</code>: For example, <code>Reflect.construct(foo,[42,&quot;bar&quot;])</code> essentially calls <code>new foo(42,&quot;bar&quot;)</code>.</li>
</ul>
<p>Object property access, setting, and deletion can be performed manually using these utilities:</p>
<ul>
<li><code>Reflect.get(..)</code>: For example, <code>Reflect.get(o,&quot;foo&quot;)</code> retrieves <code>o.foo</code>.</li>
<li><code>Reflect.set(..)</code>: For example, <code>Reflect.set(o,&quot;foo&quot;,42)</code> essentially performs <code>o.foo = 42</code>.</li>
<li><code>Reflect.deleteProperty(..)</code>: For example, <code>Reflect.deleteProperty(o,&quot;foo&quot;)</code> essentially performs <code>delete o.foo</code>.</li>
</ul>
<p>The meta programming capabilities of <code>Reflect</code> give you programmatic equivalents to emulate various syntactic features, exposing previously hidden-only abstract operations. For example, you can use these capabilities to extend features and APIs for <em>domain specific languages</em> (DSLs).</p>
<h3>Property Ordering</h3>
<p>Prior to ES6, the order used to list an object's keys/properties was implementation dependent and undefined by the specification. Generally, most engines have enumerated them in creation order, though developers have been strongly encouraged not to ever rely on this ordering.</p>
<p>As of ES6, the order for listing owned properties is now defined (ES6 specification, section 9.1.12) by the <code>[[OwnPropertyKeys]]</code> algorithm, which produces all owned properties (strings or symbols), regardless of enumerability. This ordering is only guaranteed for <code>Reflect.ownKeys(..)</code> (and by extension, <code>Object.getOwnPropertyNames(..)</code> and <code>Object.getOwnPropertySymbols(..)</code>).</p>
<p>The ordering is:</p>
<ol>
<li>First, enumerate any owned properties that are integer indexes, in ascending numeric order.</li>
<li>Next, enumerate the rest of the owned string property names in creation order.</li>
<li>Finally, enumerate owned symbol properties in creation order.</li>
</ol>
<p>Consider:</p>
<pre><code class="language-js">var o = {};

o[Symbol(&quot;c&quot;)] = &quot;yay&quot;;
o[2] = true;
o[1] = true;
o.b = &quot;awesome&quot;;
o.a = &quot;cool&quot;;

Reflect.ownKeys( o );               // [1,2,&quot;b&quot;,&quot;a&quot;,Symbol(c)]
Object.getOwnPropertyNames( o );    // [1,2,&quot;b&quot;,&quot;a&quot;]
Object.getOwnPropertySymbols( o );  // [Symbol(c)]
</code></pre>
<p>On the other hand, the <code>[[Enumerate]]</code> algorithm (ES6 specification, section 9.1.11) produces only enumerable properties, from the target object as well as its <code>[[Prototype]]</code> chain. It is used by both <code>Reflect.enumerate(..)</code> and <code>for..in</code>. The observable ordering is implementation dependent and not controlled by the specification.</p>
<p>By contrast, <code>Object.keys(..)</code> invokes the <code>[[OwnPropertyKeys]]</code> algorithm to get a list of all owned keys. However, it filters out non-enumerable properties and then reorders the list to match legacy implementation-dependent behavior, specifically with <code>JSON.stringify(..)</code> and <code>for..in</code>. So, by extension the ordering <em>also</em> matches that of <code>Reflect.enumerate(..)</code>.</p>
<p>In other words, all four mechanisms (<code>Reflect.enumerate(..)</code>, <code>Object.keys(..)</code>, <code>for..in</code>, and <code>JSON.stringify(..)</code>) will  match with the same implementation-dependent ordering, though they technically get there in different ways.</p>
<p>Implementations are allowed to match these four to the ordering of <code>[[OwnPropertyKeys]]</code>, but are not required to. Nevertheless, you will likely observe the following ordering behavior from them:</p>
<pre><code class="language-js">var o = { a: 1, b: 2 };
var p = Object.create( o );
p.c = 3;
p.d = 4;

for (var prop of Reflect.enumerate( p )) {
    console.log( prop );
}
// c d a b

for (var prop in p) {
    console.log( prop );
}
// c d a b

JSON.stringify( p );
// {&quot;c&quot;:3,&quot;d&quot;:4}

Object.keys( p );
// [&quot;c&quot;,&quot;d&quot;]
</code></pre>
<p>Boiling this all down: as of ES6, <code>Reflect.ownKeys(..)</code>, <code>Object.getOwnPropertyNames(..)</code>, and <code>Object.getOwnPropertySymbols(..)</code> all have predictable and reliable ordering guaranteed by the specification. So it's safe to build code that relies on this ordering.</p>
<p><code>Reflect.enumerate(..)</code>, <code>Object.keys(..)</code>, and <code>for..in</code> (as well as <code>JSON.stringification(..)</code> by extension) continue to share an observable ordering with each other, as they always have. But that ordering will not necessarily be the same as that of <code>Reflect.ownKeys(..)</code>. Care should still be taken in relying on their implementation-dependent ordering.</p>
<h2>Feature Testing</h2>
<p>What is a feature test? It's a test that you run to determine if a feature is available or not. Sometimes, the test is not just for existence, but for conformance to specified behavior -- features can exist but be buggy.</p>
<p>This is a meta programming technique, to test the environment your program runs in to then determine how your program should behave.</p>
<p>The most common use of feature tests in JS is checking for the existence of an API and if it's not present, defining a polyfill (see Chapter 1). For example:</p>
<pre><code class="language-js">if (!Number.isNaN) {
    Number.isNaN = function(x) {
        return x !== x;
    };
}
</code></pre>
<p>The <code>if</code> statement in this snippet is meta programming: we're probing our program and its runtime environment to determine if and how we should proceed.</p>
<p>But what about testing for features that involve new syntax?</p>
<p>You might try something like:</p>
<pre><code class="language-js">try {
    a = () =&gt; {};
    ARROW_FUNCS_ENABLED = true;
}
catch (err) {
    ARROW_FUNCS_ENABLED = false;
}
</code></pre>
<p>Unfortunately, this doesn't work, because our JS programs are compiled. Thus, the engine will choke on the <code>() =&gt; {}</code> syntax if it is not already supporting ES6 arrow functions. Having a syntax error in your program prevents it from running, which prevents your program from subsequently responding differently if the feature is supported or not.</p>
<p>To meta program with feature tests around syntax-related features, we need a way to insulate the test from the initial compile step our program runs through. For instance, if we could store the code for the test in a string, then the JS engine wouldn't by default try to compile the contents of that string, until we asked it to.</p>
<p>Did your mind just jump to using <code>eval(..)</code>?</p>
<p>Not so fast. See the <em>Scope &amp; Closures</em> title of this series for why <code>eval(..)</code> is a bad idea. But there's another option with less downsides: the <code>Function(..)</code> constructor.</p>
<p>Consider:</p>
<pre><code class="language-js">try {
    new Function( &quot;( () =&gt; {} )&quot; );
    ARROW_FUNCS_ENABLED = true;
}
catch (err) {
    ARROW_FUNCS_ENABLED = false;
}
</code></pre>
<p>OK, so now we're meta programming by determining if a feature like arrow functions <em>can</em> compile in the current engine or not. You might then wonder, what would we do with this information?</p>
<p>With existence checks for APIs, and defining fallback API polyfills, there's a clear path for what to do with either test success or failure. But what can we do with the information that we get from <code>ARROW_FUNCS_ENABLED</code> being <code>true</code> or <code>false</code>?</p>
<p>Because the syntax can't appear in a file if the engine doesn't support that feature, you can't just have different functions defined in the file with and without the syntax in question.</p>
<p>What you can do is use the test to determine which of a set of JS files you should load. For example, if you had a set of these feature tests in a bootstrapper for your JS application, it could then test the environment to determine if your ES6 code can be loaded and run directly, or if you need to load a transpiled version of your code (see Chapter 1).</p>
<p>This technique is called <em>split delivery</em>.</p>
<p>It recognizes the reality that your ES6 authored JS programs will sometimes be able to entirely run &quot;natively&quot; in ES6+ browsers, but other times need transpilation to run in pre-ES6 browsers. If you always load and use the transpiled code, even in the new ES6-compliant environments, you're running suboptimal code at least some of the time. This is not ideal.</p>
<p>Split delivery is more complicated and sophisticated, but it represents a more mature and robust approach to bridging the gap between the code you write and the feature support in browsers your programs must run in.</p>
<h3>FeatureTests.io</h3>
<p>Defining feature tests for all of the ES6+ syntax, as well as the semantic behaviors, is a daunting task you probably don't want to tackle yourself. Because these tests require dynamic compilation (<code>new Function(..)</code>), there's some unfortunate performance cost.</p>
<p>Moreover, running these tests every single time your app runs is probably wasteful, as on average a user's browser only updates once in a several week period at most, and even then, new features aren't necessarily showing up with every update.</p>
<p>Finally, managing the list of feature tests that apply to your specific code base -- rarely will your programs use the entirety of ES6 -- is unruly and error-prone.</p>
<p>The &quot;https://featuretests.io&quot; feature-tests-as-a-service offers solutions to these frustrations.</p>
<p>You can load the service's library into your page, and it loads the latest test definitions and runs all the feature tests. It does so using background processing with Web Workers, if possible, to reduce the performance overhead. It also uses LocalStorage persistence to cache the results in a way that can be shared across all sites you visit which use the service, which drastically reduces how often the tests need to run on each browser instance.</p>
<p>You get runtime feature tests in each of your users' browsers, and you can use those tests results dynamically to serve users the most appropriate code (no more, no less) for their environments.</p>
<p>Moreover, the service provides tools and APIs to scan your files to determine what features you need, so you can fully automate your split delivery build processes.</p>
<p>FeatureTests.io makes it practical to use feature tests for all parts of ES6 and beyond to make sure that only the best code is ever loaded and run for any given environment.</p>
<h2>Tail Call Optimization (TCO)</h2>
<p>Normally, when a function call is made from inside another function, a second <em>stack frame</em> is allocated to separately manage the variables/state of that other function invocation. Not only does this allocation cost some processing time, but it also takes up some extra memory.</p>
<p>A call stack chain typically has at most 10-15 jumps from one function to another and another. In those scenarios, the memory usage is not likely any kind of practical problem.</p>
<p>However, when you consider recursive programming (a function calling itself repeatedly) -- or mutual recursion with two or more functions calling each other -- the call stack could easily be hundreds, thousands, or more levels deep. You can probably see the problems that could cause, if memory usage grows unbounded.</p>
<p>JavaScript engines have to set an arbitrary limit to prevent such programming techniques from crashing by running the browser and device out of memory. That's why we get the frustrating &quot;RangeError: Maximum call stack size exceeded&quot; thrown if the limit is hit.</p>
<p><strong>Warning:</strong> The limit of call stack depth is not controlled by the specification. It's implementation dependent, and will vary between browsers and devices. You should never code with strong assumptions of exact observable limits, as they may very well change from release to release.</p>
<p>Certain patterns of function calls, called <em>tail calls</em>, can be optimized in a way to avoid the extra allocation of stack frames. If the extra allocation can be avoided, there's no reason to arbitrarily limit the call stack depth, so the engines can let them run unbounded.</p>
<p>A tail call is a <code>return</code> statement with a function call, where nothing has to happen after the call except returning its value.</p>
<p>This optimization can only be applied in <code>strict</code> mode. Yet another reason to always be writing all your code as <code>strict</code>!</p>
<p>Here's a function call that is <em>not</em> in tail position:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function foo(x) {
    return x * 2;
}

function bar(x) {
    // not a tail call
    return 1 + foo( x );
}

bar( 10 );              // 21
</code></pre>
<p><code>1 + ..</code> has to be performed after the <code>foo(x)</code> call completes, so the state of that <code>bar(..)</code> invocation needs to be preserved.</p>
<p>But the following snippet demonstrates calls to <code>foo(..)</code> and <code>bar(..)</code> where both <em>are</em> in tail position, as they're the last thing to happen in their code path (other than the <code>return</code>):</p>
<pre><code class="language-js">&quot;use strict&quot;;

function foo(x) {
    return x * 2;
}

function bar(x) {
    x = x + 1;
    if (x &gt; 10) {
        return foo( x );
    }
    else {
        return bar( x + 1 );
    }
}

bar( 5 );               // 24
bar( 15 );              // 32
</code></pre>
<p>In this program, <code>bar(..)</code> is clearly recursive, but <code>foo(..)</code> is just a regular function call. In both cases, the function calls are in <em>proper tail position</em>. The <code>x + 1</code> is evaluated before the <code>bar(..)</code> call, and whenever that call finishes, all that happens is the <code>return</code>.</p>
<p>Proper Tail Calls (PTC) of these forms can be optimized -- called tail call optimization (TCO) -- so that the extra stack frame allocation is unnecessary. Instead of creating a new stack frame for the next function call, the engine just reuses the existing stack frame. That works because a function doesn't need to preserve any of the current state, as nothing happens with that state after the PTC.</p>
<p>TCO means there's practically no limit to how deep the call stack can be. That trick slightly improves regular function calls in normal programs, but more importantly opens the door to using recursion for program expression even if the call stack could be tens of thousands of calls deep.</p>
<p>We're no longer relegated to simply theorizing about recursion for problem solving, but can actually use it in real JavaScript programs!</p>
<p>As of ES6, all PTC should be optimizable in this way, recursion or not.</p>
<h3>Tail Call Rewrite</h3>
<p>The hitch, however, is that only PTC can be optimized; non-PTC will still work of course, but will cause stack frame allocation as they always did. You'll have to be careful about structuring your functions with PTC if you expect the optimizations to kick in.</p>
<p>If you have a function that's not written with PTC, you may find the need to manually rearrange your code to be eligible for TCO.</p>
<p>Consider:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function foo(x) {
    if (x &lt;= 1) return 1;
    return (x / 2) + foo( x - 1 );
}

foo( 123456 );          // RangeError
</code></pre>
<p>The call to <code>foo(x-1)</code> isn't a PTC because its result has to be added to <code>(x / 2)</code> before <code>return</code>ing.</p>
<p>However, to make this code eligible for TCO in an ES6 engine, we can rewrite it as follows:</p>
<pre><code class="language-js">&quot;use strict&quot;;

var foo = (function(){
    function _foo(acc,x) {
        if (x &lt;= 1) return acc;
        return _foo( (x / 2) + acc, x - 1 );
    }

    return function(x) {
        return _foo( 1, x );
    };
})();

foo( 123456 );          // 3810376848.5
</code></pre>
<p>If you run the previous snippet in an ES6 engine that implements TCO, you'll get the <code>3810376848.5</code> answer as shown. However, it'll still fail with a <code>RangeError</code> in non-TCO engines.</p>
<h3>Non-TCO Optimizations</h3>
<p>There are other techniques to rewrite the code so that the call stack isn't growing with each call.</p>
<p>One such technique is called <em>trampolining</em>, which amounts to having each partial result represented as a function that either returns another partial result function or the final result. Then you can simply loop until you stop getting a function, and you'll have the result. Consider:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function trampoline( res ) {
    while (typeof res == &quot;function&quot;) {
        res = res();
    }
    return res;
}

var foo = (function(){
    function _foo(acc,x) {
        if (x &lt;= 1) return acc;
        return function partial(){
            return _foo( (x / 2) + acc, x - 1 );
        };
    }

    return function(x) {
        return trampoline( _foo( 1, x ) );
    };
})();

foo( 123456 );          // 3810376848.5
</code></pre>
<p>This reworking required minimal changes to factor out the recursion into the loop in <code>trampoline(..)</code>:</p>
<ol>
<li>First, we wrapped the <code>return _foo ..</code> line in the <code>return partial() { ..</code> function expression.</li>
<li>Then we wrapped the <code>_foo(1,x)</code> call in the <code>trampoline(..)</code> call.</li>
</ol>
<p>The reason this technique doesn't suffer the call stack limitation is that each of those inner <code>partial(..)</code> functions is just returned back to the <code>while</code> loop in <code>trampoline(..)</code>, which runs it and then loop iterates again. In other words, <code>partial(..)</code> doesn't recursively call itself, it just returns another function. The stack depth remains constant, so it can run as long as it needs to.</p>
<p>Trampolining expressed in this way uses the closure that the inner <code>partial()</code> function has over the <code>x</code> and <code>acc</code> variables to keep the state from iteration to iteration. The advantage is that the looping logic is pulled out into a reusable <code>trampoline(..)</code> utility function, which many libraries provide versions of. You can reuse <code>trampoline(..)</code> multiple times in your program with different trampolined algorithms.</p>
<p>Of course, if you really wanted to deeply optimize (and the reusability wasn't a concern), you could discard the closure state and inline the state tracking of <code>acc</code> into just one function's scope along with a loop. This technique is generally called <em>recursion unrolling</em>:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function foo(x) {
    var acc = 1;
    while (x &gt; 1) {
        acc = (x / 2) + acc;
        x = x - 1;
    }
    return acc;
}

foo( 123456 );          // 3810376848.5
</code></pre>
<p>This expression of the algorithm is simpler to read, and will likely perform the best (strictly speaking) of the various forms we've explored. That may seem like a clear winner, and you may wonder why you would ever try the other approaches.</p>
<p>There are some reasons why you might not want to always manually unroll your recursions:</p>
<ul>
<li><p>Instead of factoring out the trampolining (loop) logic for reusability, we've inlined it. This works great when there's only one example to consider, but as soon as you have a half dozen or more of these in your program, there's a good chance you'll want some reusability to keep things shorter and more manageable.</p></li>
<li><p>The example here is deliberately simple enough to illustrate the different forms. In practice, there are many more complications in recursion algorithms, such as mutual recursion (more than just one function calling itself).</p>
<p>The farther you go down this rabbit hole, the more manual and intricate the <em>unrolling</em> optimizations are. You'll quickly lose all the perceived value of readability. The primary advantage of recursion, even in the PTC form, is that it preserves the algorithm readability, and offloads the performance optimization to the engine.</p></li>
</ul>
<p>If you write your algorithms with PTC, the ES6 engine will apply TCO to let your code run in constant stack depth (by reusing stack frames). You get the readability of recursion with most of the performance benefits and no limitations of run length.</p>
<h3>Meta?</h3>
<p>What does TCO have to do with meta programming?</p>
<p>As we covered in the &quot;Feature Testing&quot; section earlier, you can determine at runtime what features an engine supports. This includes TCO, though determining it is quite brute force. Consider:</p>
<pre><code class="language-js">&quot;use strict&quot;;

try {
    (function foo(x){
        if (x &lt; 5E5) return foo( x + 1 );
    })( 1 );

    TCO_ENABLED = true;
}
catch (err) {
    TCO_ENABLED = false;
}
</code></pre>
<p>In a non-TCO engine, the recursive loop will fail out eventually, throwing an exception caught by the <code>try..catch</code>. Otherwise, the loop completes easily thanks to TCO.</p>
<p>Yuck, right?</p>
<p>But how could meta programming around the TCO feature (or rather, the lack thereof) benefit our code? The simple answer is that you could use such a feature test to decide to load a version of your application's code that uses recursion, or an alternative one that's been converted/transpiled to not need recursion.</p>
<h4>Self-Adjusting Code</h4>
<p>But here's another way of looking at the problem:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function foo(x) {
    function _foo() {
        if (x &gt; 1) {
            acc = acc + (x / 2);
            x = x - 1;
            return _foo();
        }
    }

    var acc = 1;

    while (x &gt; 1) {
        try {
            _foo();
        }
        catch (err) { }
    }

    return acc;
}

foo( 123456 );          // 3810376848.5
</code></pre>
<p>This algorithm works by attempting to do as much of the work with recursion as possible, but keeping track of the progress via scoped variables <code>x</code> and <code>acc</code>. If the entire problem can be solved with recursion without an error, great. If the engine kills the recursion at some point, we simply catch that with the <code>try..catch</code> and then try again, picking up where we left off.</p>
<p>I consider this a form of meta programming in that you are probing during runtime the ability of the engine to fully (recursively) finish the task, and working around any (non-TCO) engine limitations that may restrict you.</p>
<p>At first (or even second!) glance, my bet is this code seems much uglier to you compared to some of the earlier versions. It also runs a fair bit slower (on larger runs in a non-TCO environment).</p>
<p>The primary advantage, other than it being able to complete any size task even in non-TCO engines, is that this &quot;solution&quot; to the recursion stack limitation is much more flexible than the trampolining or manual unrolling techniques shown previously.</p>
<p>Essentially, <code>_foo()</code> in this case is a sort of stand-in for practically any recursive task, even mutual recursion. The rest is the boilerplate that should work for just about any algorithm.</p>
<p>The only &quot;catch&quot; is that to be able to resume in the event of a recursion limit being hit, the state of the recursion must be in scoped variables that exist outside the recursive function(s). We did that by leaving <code>x</code> and <code>acc</code> outside of the <code>_foo()</code> function, instead of passing them as arguments to <code>_foo()</code> as earlier.</p>
<p>Almost any recursive algorithm can be adapted to work this way. That means it's the most widely applicable way of leveraging TCO with recursion in your programs, with minimal rewriting.</p>
<p>This approach still uses a PTC, meaning that this code will <em>progressively enhance</em> from running using the loop many times (recursion batches) in an older browser to fully leveraging TCO'd recursion in an ES6+ environment. I think that's pretty cool!</p>
<h2>Review</h2>
<p>Meta programming is when you turn the logic of your program to focus on itself (or its runtime environment), either to inspect its own structure or to modify it. The primary value of meta programming is to extend the normal mechanisms of the language to provide additional capabilities.</p>
<p>Prior to ES6, JavaScript already had quite a bit of meta programming capability, but ES6 significantly ramps that up with several new features.</p>
<p>From function name inferences for anonymous functions to meta properties that give you information about things like how a constructor was invoked, you can inspect the program structure while it runs more than ever before. Well Known Symbols let you override intrinsic behaviors, such as coercion of an object to a primitive value. Proxies can intercept and customize various low-level operations on objects, and <code>Reflect</code> provides utilities to emulate them.</p>
<p>Feature testing, even for subtle semantic behaviors like Tail Call Optimization, shifts the meta programming focus from your program to the JS engine capabilities itself. By knowing more about what the environment can do, your programs can adjust themselves to the best fit as they run.</p>
<p>Should you meta program? My advice is: first focus on learning how the core mechanics of the language really work. But once you fully know what JS itself can do, it's time to start leveraging these powerful meta programming capabilities to push the language further!</p>
</section>
   </body>
 </html>
