<!doctype html>
 <html>
   <head>
     <link rel="stylesheet" href="../style.css">
     <title>Scope &amp; Closures</title>
     <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/github.min.css">
     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script>
     <script>document.addEventListener("DOMContentLoaded", () => hljs.initHighlightingOnLoad());</script>
   </head>
   <body>
     <section id="main"><h1>You Don't Know JS: Scope &amp; Closures</h1>
<h1>Appendix A: Dynamic Scope</h1>
<p>In Chapter 2, we talked about &quot;Dynamic Scope&quot; as a contrast to the &quot;Lexical Scope&quot; model, which is how scope works in JavaScript (and in fact, most other languages).</p>
<p>We will briefly examine dynamic scope, to hammer home the contrast. But, more importantly, dynamic scope actually is a near cousin to another mechanism (<code>this</code>) in JavaScript, which we covered in the &quot;<em>this &amp; Object Prototypes</em>&quot; title of this book series.</p>
<p>As we saw in Chapter 2, lexical scope is the set of rules about how the <em>Engine</em> can look-up a variable and where it will find it. The key characteristic of lexical scope is that it is defined at author-time, when the code is written (assuming you don't cheat with <code>eval()</code> or <code>with</code>).</p>
<p>Dynamic scope seems to imply, and for good reason, that there's a model whereby scope can be determined dynamically at runtime, rather than statically at author-time. That is in fact the case. Let's illustrate via code:</p>
<pre><code class="language-js">function foo() {
    console.log( a ); // 2
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;

bar();
</code></pre>
<p>Lexical scope holds that the RHS reference to <code>a</code> in <code>foo()</code> will be resolved to the global variable <code>a</code>, which will result in value <code>2</code> being output.</p>
<p>Dynamic scope, by contrast, doesn't concern itself with how and where functions and scopes are declared, but rather <strong>where they are called from</strong>. In other words, the scope chain is based on the call-stack, not the nesting of scopes in code.</p>
<p>So, if JavaScript had dynamic scope, when <code>foo()</code> is executed, <strong>theoretically</strong> the code below would instead result in <code>3</code> as the output.</p>
<pre><code class="language-js">function foo() {
    console.log( a ); // 3  (not 2!)
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;

bar();
</code></pre>
<p>How can this be? Because when <code>foo()</code> cannot resolve the variable reference for <code>a</code>, instead of stepping up the nested (lexical) scope chain, it walks up the call-stack, to find where <code>foo()</code> was <em>called from</em>. Since <code>foo()</code> was called from <code>bar()</code>, it checks the variables in scope for <code>bar()</code>, and finds an <code>a</code> there with value <code>3</code>.</p>
<p>Strange? You're probably thinking so, at the moment.</p>
<p>But that's just because you've probably only ever worked on (or at least deeply considered) code which is lexically scoped. So dynamic scoping seems foreign. If you had only ever written code in a dynamically scoped language, it would seem natural, and lexical scope would be the odd-ball.</p>
<p>To be clear, JavaScript <strong>does not, in fact, have dynamic scope</strong>. It has lexical scope. Plain and simple. But the <code>this</code> mechanism is kind of like dynamic scope.</p>
<p>The key contrast: <strong>lexical scope is write-time, whereas dynamic scope (and <code>this</code>!) are runtime</strong>. Lexical scope cares <em>where a function was declared</em>, but dynamic scope cares where a function was <em>called from</em>.</p>
<p>Finally: <code>this</code> cares <em>how a function was called</em>, which shows how closely related the <code>this</code> mechanism is to the idea of dynamic scoping. To dig more into <code>this</code>, read the title &quot;<em>this &amp; Object Prototypes</em>&quot;.</p>
</section>
   </body>
 </html>
